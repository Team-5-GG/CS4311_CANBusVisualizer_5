"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Can_dbc;
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../dbc/errors");
const errors_2 = require("./errors");
const BitUtils_1 = __importDefault(require("./BitUtils"));
class Can extends BitUtils_1.default {
    constructor(dbc) {
        super();
        _Can_dbc.set(this, void 0);
        __classPrivateFieldSet(this, _Can_dbc, dbc, "f");
    }
    set dbc(dbc) {
        __classPrivateFieldSet(this, _Can_dbc, dbc, "f");
    }
    createFrame(id, payload) {
        if (payload.length > 8) {
            throw new errors_2.InvalidPayloadLength(`Can not have payloads over 8 bytes: ${payload}`);
        }
        else if (payload.length === 0) {
            throw new errors_2.InvalidPayloadLength(`Payload is either empty or undefined: ${payload}`);
        }
        // Uint8Array will ensure values don't exceed 255
        const byteArray = new Uint8ClampedArray(payload);
        const canFrame = {
            id,
            dlc: payload.length,
            isExtended: id > 2048,
            payload: Array.from(byteArray),
        };
        return canFrame;
    }
    decode(frame) {
        const msg = this.getMessageById(frame.id);
        if (msg.dlc !== frame.dlc) {
            return undefined;
        }
        const signals = new Map();
        for (const [name, signal] of msg.signals) {
            const bndSig = this.decodeSignal(frame.payload, signal);
            signals.set(name, bndSig);
        }
        const boundMessage = {
            name: msg.name,
            id: msg.id,
            signals,
        };
        return boundMessage;
    }
    getMessageById(id) {
        const messages = __classPrivateFieldGet(this, _Can_dbc, "f").messages;
        for (const [name, message] of messages) {
            if (message.id === id) {
                return message;
            }
        }
        throw new errors_1.MessageDoesNotExist(`No message with id ${id} exists in the database.`);
    }
    decodeSignal(payload, signal) {
        const rawValue = this.getValue(payload, signal.startBit, signal.length, signal.endianness, signal.signed);
        // Apply scaling and offset
        let prcValue = rawValue * signal.factor + signal.offset;
        // Determine if we need to enforce min/maxs on the value
        if (signal.min === 0 && signal.max === 0) {
            prcValue = prcValue;
        }
        else if (prcValue < signal.min) {
            prcValue = signal.min;
        }
        else if (prcValue > signal.max) {
            prcValue = signal.max;
        }
        // If we have an enumeration, return enumeration member for physical value, otherwise return with units
        let physValue;
        if (signal.valueTable) {
            const enumMem = signal.valueTable.get(prcValue);
            if (enumMem) {
                physValue = enumMem;
            }
            else {
                physValue = prcValue.toString() + (signal.unit ? ' ' + signal.unit : '');
            }
        }
        else {
            physValue = prcValue.toString() + (signal.unit ? ' ' + signal.unit : '');
        }
        return {
            value: prcValue,
            rawValue,
            physValue,
        };
    }
    getValue(data, startBit, signalLength, endian, signed) {
        let signalData = new Array(signalLength).fill(0);
        let targetBit = startBit;
        for (let i = 0; i < signalLength; ++i) {
            const targetByteIndex = Math.ceil((targetBit + 1) / 8);
            // Need to handle bit field correctly since LSB starts at end of array
            const targetBitIdx = 7 - (targetBit - (targetByteIndex - 1) * 8);
            const val = this.bitGet(data[targetByteIndex - 1], targetBitIdx);
            if (val) {
                signalData = this.bitSet(signalData, i, Number(val));
            }
            if (endian === 'Motorola' && targetBitIdx === 0) {
                targetBit = targetBit - 15;
            }
            else {
                targetBit = targetBit + 1;
            }
        }
        let prcValue;
        if (signed) {
            prcValue = Number(this.bin2decSigned(signalData.join('')));
        }
        else {
            prcValue = Number(this.bin2dec(signalData.join('')));
        }
        return prcValue;
    }
}
_Can_dbc = new WeakMap();
exports.default = Can;
//# sourceMappingURL=can.js.map
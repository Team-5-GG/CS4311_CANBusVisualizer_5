import { Message, Signal, DbcData, EndianType, ValueTable } from './types';
import Parser from './parser';
/**
 * Creates a DBC instance that allows for parsing/loading of an existing DBC file
 * or write data to a new DBC file.
 *
 * If loading data from an existing file, simply call:
 * const dbc = new Dbc();
 * dbc.load('path/to/my/dbcFile.dbc')
 *
 * load() loads the dbc data async., so to pull the data from the class instance
 * you will either need to wrap the call in an async function or call .then(data)
 * ex. dbc.load('path/to/my/dbcFile.dbc').then( data => DO SOMETHING WITH DATA HERE )
 *
 * By default when a new Dbc() instance is created, the encapulsated data will be empty.
 * If you are wanting to create fresh data you can call createMessage or createSignal to
 * create messages and signals, respectively.
 * Calls to createMessage and createSignal do not by default add the messages to the data,
 * you will need to make subsequent calls to addMessage or addSignal to add the data
 * to the class.
 *
 * To write data to a dbc file, you can call write() function.
 * write() expects a path to the dbc file
 *
 */
declare class Dbc extends Parser {
    data: DbcData;
    constructor();
    /**
     * Adds a version number to dbc data
     */
    set version(version: string);
    /**
     * Adds a bus speed configuration
     */
    set busConfiguration(speed: number);
    /**
     * Adds a list of CAN nodes that exist for the network topology
     */
    set canNodes(nodes: string[]);
    /**
     * Adds a short description for the DBC data
     */
    set description(description: string);
    /**
     *
     * Creates a Message instance that can later be added using addMessage()
     *
     * @param name Name of CAN message
     * @param id ID of CAN message
     * @param dlc Data Length Code (data length) of CAN message
     * @param sendingNode Name of node that sends this message
     * @param description Short description of what the message is/does
     * @returns Message
     */
    createMessage(name: string, id: number, dlc: number, sendingNode?: null | string, description?: null | string): Message;
    /**
     *
     * Adds/appends message to existing message list
     *
     * @param message Message object to be added
     */
    addMessage(message: Message | Message[]): void;
    removeMessage(messageName: string): void;
    createSignal(name: string, startBit: number, length: number, signed?: boolean, endianness?: EndianType, min?: number, max?: number, factor?: number, offset?: number, unit?: string | null, description?: string | null, multiplex?: string | null, receivingNodes?: string[], valueTable?: ValueTable | null): Signal;
    removeSignal(signalName: string, messageName: string): void;
    /**
     *
     * Adds a Signal object to a specified Message
     *
     * @param messageName Name of the message the signal will be added to
     * @param signal Signal object to be added to the specified message
     */
    addSignal(messageName: string, signal: Signal | Signal[]): void;
    /**
     *
     * Returns a message with the corresponding CAN ID. If message does not exist
     * a MessageDoesNotExist error will be thrown.
     *
     * @param id The CAN ID of the message wanting to be found
     * @returns Message
     * @throws MessageDoesNotExist
     */
    getMessageById(id: number): Message;
    /**
     *
     * Finds a specific message within the DBC file data by name
     *
     * @param name string
     * @returns Message
     * @error MessageDoesNotExist
     */
    getMessageByName(name: string): Message | undefined;
    /**
     *
     * Returns a signal object located in a specific CAN message by name
     *
     * @param name string
     * @param messageName string
     * @returns Signal
     * @error SignalDoesNotExist
     */
    getSignalByName(name: string, messageName: string): Signal;
    /**
     *
     * @param file string
     * @returns Promise<DbcData>
     */
    load(file: string): Promise<DbcData>;
    /**
     *
     * Writes the encapsulated data of a Dbc class instance to a dbc file
     *
     * @param filePath Path to the file/dbc to be written to. If it does not exist at the path, the file
     * will automatically be created.
     */
    write(filePath: string): void;
    /**
     *
     * Transforms the internal DBC data from class instance into a JSON object/string
     *
     * @param pretty Determines if JSON output should be formatted. Defaults to true.
     * @returns JSON representation of loaded DBC data
     */
    toJson(pretty?: boolean): string;
}
export default Dbc;

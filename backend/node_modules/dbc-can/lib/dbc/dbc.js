"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const readline = __importStar(require("readline"));
const parser_1 = __importDefault(require("./parser"));
const writer_1 = __importDefault(require("./writer"));
const errors_1 = require("./errors");
/**
 * Creates a DBC instance that allows for parsing/loading of an existing DBC file
 * or write data to a new DBC file.
 *
 * If loading data from an existing file, simply call:
 * const dbc = new Dbc();
 * dbc.load('path/to/my/dbcFile.dbc')
 *
 * load() loads the dbc data async., so to pull the data from the class instance
 * you will either need to wrap the call in an async function or call .then(data)
 * ex. dbc.load('path/to/my/dbcFile.dbc').then( data => DO SOMETHING WITH DATA HERE )
 *
 * By default when a new Dbc() instance is created, the encapulsated data will be empty.
 * If you are wanting to create fresh data you can call createMessage or createSignal to
 * create messages and signals, respectively.
 * Calls to createMessage and createSignal do not by default add the messages to the data,
 * you will need to make subsequent calls to addMessage or addSignal to add the data
 * to the class.
 *
 * To write data to a dbc file, you can call write() function.
 * write() expects a path to the dbc file
 *
 */
class Dbc extends parser_1.default {
    constructor() {
        super();
        this.data = {
            version: null,
            messages: new Map(),
            description: null,
            busConfiguration: null,
            canNodes: new Array(),
            valueTables: null,
            attributes: null,
        };
    }
    /**
     * Adds a version number to dbc data
     */
    set version(version) {
        this.data.version = version;
    }
    /**
     * Adds a bus speed configuration
     */
    set busConfiguration(speed) {
        // TODO: Might need to do some input validation to ensure we are not writing bad
        // data to a dbc file
        this.data.busConfiguration = speed;
    }
    /**
     * Adds a list of CAN nodes that exist for the network topology
     */
    set canNodes(nodes) {
        this.data.canNodes = nodes;
    }
    /**
     * Adds a short description for the DBC data
     */
    set description(description) {
        this.data.description = description;
    }
    /**
     *
     * Creates a Message instance that can later be added using addMessage()
     *
     * @param name Name of CAN message
     * @param id ID of CAN message
     * @param dlc Data Length Code (data length) of CAN message
     * @param sendingNode Name of node that sends this message
     * @param description Short description of what the message is/does
     * @returns Message
     */
    createMessage(name, id, dlc, sendingNode = null, description = null) {
        const message = {
            name,
            id,
            dlc,
            sendingNode,
            signals: new Map(),
            description,
        };
        return message;
    }
    /**
     *
     * Adds/appends message to existing message list
     *
     * @param message Message object to be added
     */
    addMessage(message) {
        if (Array.isArray(message)) {
            message.forEach((msg) => {
                this.data.messages.set(msg.name, msg);
            });
        }
        else {
            this.data.messages.set(message.name, message);
        }
        // TODO Validate that message ID does not conflict
        // with other IDs. If it does, throw error
    }
    removeMessage(messageName) {
        this.data.messages.delete(messageName);
    }
    createSignal(name, startBit, length, signed = false, endianness = 'Intel', min = 0, max = 0, factor = 1, offset = 0, unit = null, description = null, multiplex = null, receivingNodes = new Array(), valueTable = null) {
        if (!unit) {
            unit = '';
        }
        const signal = {
            name,
            multiplex,
            startBit,
            length,
            endianness,
            signed,
            factor,
            offset,
            min,
            max,
            unit,
            receivingNodes,
            description,
            valueTable,
        };
        return signal;
    }
    removeSignal(signalName, messageName) {
        const msg = this.getMessageByName(messageName);
        msg === null || msg === void 0 ? void 0 : msg.signals.delete(signalName);
    }
    /**
     *
     * Adds a Signal object to a specified Message
     *
     * @param messageName Name of the message the signal will be added to
     * @param signal Signal object to be added to the specified message
     */
    addSignal(messageName, signal) {
        const message = this.data.messages.get(messageName);
        if (message) {
            if (Array.isArray(signal)) {
                signal.forEach((sig) => {
                    message.signals.set(sig.name, sig);
                });
            }
            else {
                message.signals.set(signal.name, signal);
            }
        }
        else {
            throw new errors_1.MessageDoesNotExist(`No message with name ${messageName} exists in the database.`);
        }
    }
    /**
     *
     * Returns a message with the corresponding CAN ID. If message does not exist
     * a MessageDoesNotExist error will be thrown.
     *
     * @param id The CAN ID of the message wanting to be found
     * @returns Message
     * @throws MessageDoesNotExist
     */
    getMessageById(id) {
        const messages = this.data.messages;
        for (const [name, message] of messages) {
            if (message.id === id) {
                return message;
            }
        }
        throw new errors_1.MessageDoesNotExist(`No message with id ${id} exists in the database.`);
    }
    /**
     *
     * Finds a specific message within the DBC file data by name
     *
     * @param name string
     * @returns Message
     * @error MessageDoesNotExist
     */
    getMessageByName(name) {
        try {
            const msg = this.data.messages.get(name);
            return msg;
        }
        catch (e) {
            throw new errors_1.MessageDoesNotExist(`No message with name ${name} exists in the database.`);
        }
    }
    /**
     *
     * Returns a signal object located in a specific CAN message by name
     *
     * @param name string
     * @param messageName string
     * @returns Signal
     * @error SignalDoesNotExist
     */
    getSignalByName(name, messageName) {
        const msg = this.getMessageByName(messageName);
        const signals = msg === null || msg === void 0 ? void 0 : msg.signals;
        if (signals) {
            for (const [signal, signalObj] of signals) {
                if (signal === name) {
                    return signalObj;
                }
            }
        }
        else {
            throw new errors_1.SignalDoesNotExist(`Signal could not be found in ${messageName}, because the
      signal list for that message is empty.`);
        }
        throw new errors_1.SignalDoesNotExist(`Could not find ${name} in signal list.`);
    }
    /**
     *
     * @param file string
     * @returns Promise<DbcData>
     */
    load(file) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const fileStream = fs.createReadStream(file);
            // Note: we use the crlfDelay option to recognize all instances of CR LF
            // ('\r\n') in input.txt as a single line break.
            const rl = readline.createInterface({
                input: fileStream,
                crlfDelay: Infinity,
            });
            let lineInfo = null;
            let data = {
                version: null,
                messages: new Map(),
                description: null,
                busConfiguration: null,
                canNodes: new Array(),
                valueTables: new Map(),
                attributes: null,
            };
            try {
                for (var rl_1 = __asyncValues(rl), rl_1_1; rl_1_1 = yield rl_1.next(), !rl_1_1.done;) {
                    const line = rl_1_1.value;
                    lineInfo = this.parseLine(line);
                    data = this.parseLineFromBaseToken(lineInfo, data);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (rl_1_1 && !rl_1_1.done && (_a = rl_1.return)) yield _a.call(rl_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Add table data to class instance for future referencing
            this.data = data;
            return data;
        });
    }
    /**
     *
     * Writes the encapsulated data of a Dbc class instance to a dbc file
     *
     * @param filePath Path to the file/dbc to be written to. If it does not exist at the path, the file
     * will automatically be created.
     */
    write(filePath) {
        const writer = new writer_1.default(filePath);
        writer.constructFile(this.data);
    }
    /**
     *
     * Transforms the internal DBC data from class instance into a JSON object/string
     *
     * @param pretty Determines if JSON output should be formatted. Defaults to true.
     * @returns JSON representation of loaded DBC data
     */
    toJson(pretty = true) {
        const replacer = (key, value) => {
            if (value instanceof Map) {
                if (key === 'valueTable' || key === 'valueTables') {
                    return Object.fromEntries(value.entries());
                }
                return Array.from(value.values()); // or with spread: value: [...value]
            }
            else {
                return value;
            }
        };
        let indent = 0;
        if (pretty) {
            indent = 2;
        }
        const json = JSON.stringify(this.data, replacer, indent);
        return json;
    }
}
exports.default = Dbc;
//# sourceMappingURL=dbc.js.map
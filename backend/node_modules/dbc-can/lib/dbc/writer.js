"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
class Writer {
    constructor(file, overwrite = false) {
        this.file = file;
    }
    /**
     * Main constructor class that will organize and write all
     * attributes of DbcData structure
     * @param data dbc data loaded or created using main DBC class
     */
    constructFile(data) {
        // This will clear out the file before writing to it
        fs.writeFileSync(this.file, '', { flag: 'w+' });
        // Main file attributes
        this.writeVersion(data.version ? data.version : '');
        this.writeNamespace();
        this.writeBusSpeed(data.busConfiguration);
        this.writeNodes(data.canNodes);
        // Both messages and signals
        this.writeMessagesAndSignals(data.messages);
        // Write all comments
        if (data.description) {
            this.writeBaseComment(data.description);
        }
        this.writeMessageAndSignalComments(data.messages);
        if (data.valueTables) {
            this.writeValTable(data.valueTables);
        }
        this.writeSignalTables(data.messages);
    }
    /**
     *
     * @param version Version of the dbc file
     */
    writeVersion(version) {
        const lineContent = `VERSION "${version}"`;
        this.writeLine(lineContent);
        this.writeLine('');
    }
    writeNamespace(ns = null) {
        // TODO: For now since name space technically doesn't need
        // to be complete for a valid DBC file, we will skip it's content
        // and just render the main token
        const lineContent = `NS_:`;
        this.writeLine(lineContent);
        this.writeLine('');
    }
    /**
     * Speed of the CAN bus, typically expressed as 250, 500, etc
     * @param busConfiguration Speed of the CAN bus
     */
    writeBusSpeed(busConfiguration) {
        let lineContent = '';
        if (busConfiguration === null) {
            lineContent = `BS_:`;
        }
        else {
            lineContent = `BS_: ${busConfiguration}`;
        }
        this.writeLine(lineContent);
        this.writeLine('');
    }
    /**
     * Generic list of nodes that exist for the CAN architecture
     * @param nodes List of nodes that are attached to messages and signals
     */
    writeNodes(nodes) {
        let lineContent = '';
        if (nodes === null || nodes.length === 0) {
            lineContent = `BU_:`;
        }
        else {
            // TODO: Actually enumerate list out
            lineContent = `BU_:`;
        }
        this.writeLine(lineContent);
        this.writeLine('');
    }
    /**
     *
     * @param message Individual message to be written to the file
     */
    writeMessagesAndSignals(messages) {
        for (const [name, message] of messages) {
            let node;
            if (message.sendingNode) {
                node = message.sendingNode;
            }
            else {
                // Default that is typically generated from CANDB++ (from Vector)
                node = 'Vector___XXX';
            }
            const lineContent = `BO_ ${message.id.toString()} ${message.name}: ${message.dlc.toString()} ${node}`;
            this.writeLine(lineContent);
            // Extract signals and exand in file
            for (const [signalName, signal] of message.signals) {
                this.writeSignal(signal);
            }
            this.writeLine('');
        }
    }
    /**
     *
     * @param signal Signal to be writen to dbc file
     */
    writeSignal(signal) {
        const endian = signal.endianness === 'Motorola' ? '0' : '1';
        const sign = signal.signed ? '-' : '+';
        const nodes = signal.receivingNodes.length === 0 ? 'Vector___XXXX' : signal.receivingNodes.join(' ');
        const name = signal.multiplex ? signal.name + ' ' + signal.multiplex : signal.name;
        // Format: SG_ Signal0 : 0|32@1- (1,0) [0|0] "" Node1
        const lineContent = ` SG_ ` +
            `${name} : ${signal.startBit.toString()}|${signal.length.toString()}@${endian}${sign}` +
            ` (${signal.factor.toString()},${signal.offset.toString()}) [${signal.min.toString()}|${signal.max.toString()}] ` +
            `"${signal.unit}" ${nodes}`;
        this.writeLine(lineContent);
    }
    /**
     * Main writer function for class. New line character will be added automatically
     * to each line, so subsquent calls to this function
     * will automatically start on the next line.
     *
     * @param line Line content to write to file
     * @param skipNextLine If next line should be a blank line
     */
    writeLine(line) {
        fs.writeFileSync(this.file, `${line}\n`, { flag: 'a+' });
    }
    writeBaseComment(comment) {
        this.writeLine(`CM_ "${comment}" ;`);
    }
    writeMessageAndSignalComments(messages) {
        for (const [name, msg] of messages) {
            if (msg.description) {
                this.writeLine(`CM_ BO_ ${msg.id.toString()} "${msg.description}" ;`);
            }
            for (const [signalName, signal] of msg.signals) {
                if (signal.description) {
                    this.writeLine(`CM_ SG_ ${msg.id.toString()} ${signalName} "${signal.description}" ;`);
                }
            }
        }
    }
    generateEnumTable(tableMembers) {
        let members = '';
        for (const [enumVal, enumName] of tableMembers) {
            members = members + enumVal.toString() + ' ' + `"${enumName}"` + ' ';
        }
        return `${members}`;
    }
    writeValTable(valueTable) {
        for (const [name, tableMembers] of valueTable) {
            const members = this.generateEnumTable(tableMembers);
            const lineContent = `VAL_TABLE_ ${name} ${members};`;
            this.writeLine(lineContent);
        }
        this.writeLine('');
    }
    writeSignalTables(messages) {
        for (const [name, msg] of messages) {
            for (const [signalName, signal] of msg.signals) {
                if (signal.valueTable) {
                    const members = this.generateEnumTable(signal.valueTable);
                    const lineContent = `VAL_ ${msg.id.toString()} ${signal.name} ${members};`;
                    this.writeLine(lineContent);
                }
            }
        }
        this.writeLine('');
    }
}
exports.default = Writer;
//# sourceMappingURL=writer.js.map